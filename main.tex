\documentclass[a4paper,8pt]{article}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fancyhdr} % For headers and footers
\usepackage{lastpage} % For total page count
\usepackage{lipsum} % For placeholder text
\usepackage{geometry}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{blindtext}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{
    colorlinks,
    linkcolor={blue!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}

\usepackage{array}

\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{tocloft}         % Пакет для настройки оглавления

\renewcommand{\cftsecleader}{\cftdotfill{2}} % Добавляем точки для секций
\renewcommand{\cftsubsecleader}{\cftdotfill{2}} % Добавляем точки для подсекций
\renewcommand{\cftbeforesubsecskip}{1em} 
\renewcommand{\cftsecindent}{2em}    % Отступ для секций
\renewcommand{\cftsubsecindent}{3em}  % Отступ для подсекций
\renewcommand{\cftsubsubsecleader}{\cftdotfill{2}} % Добавляем точки для подподсекций
\renewcommand{\cftbeforesubsubsecskip}{1em} 
\renewcommand{\cftsubsubsecindent}{4em}  % Отступ для подподсекций

% Page settings
\geometry{top=3cm, bottom=2.5cm, left=2.5cm, right=2.5cm}

% Header and footer setup
\pagestyle{fancy}
\fancyhf{} % Clear all header and footer fields

% Header
\fancyhead[L]{}
\fancyhead[R]{Страница \thepage\ из \pageref{LastPage}}




\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{orange},
    commentstyle=\color{gray}\itshape,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    frame=single,
    tabsize=4,
    inputencoding=utf8,           % кодировка входного файла
    extendedchars=true,
    captionpos=b,
    breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
    breaklines=true,
     float   
}




\begin{document}

\title{Краткий экскуfgdhjfkdhsljkтурам данных спортивного программирования}
\date{\today}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Введение}
    \subsection{Кратко о спортивном программировании}
\section{Асимптотика} 
\section{Базовая матчасть}
    \subsection{Быстрое возведение в степень}
        Текущая задача ставится очень просто: возвести некоторое число \(a\) в степень \(b\). Ограничимся тем, что $a$ и $b$ --- неотрицательные целые числа. На этом примере будет явно видна суть использования эффективных алгоритмов.

        Итак, возведение в степень можно по определению расписать в виде кратного умножения.
        \[a^b=\underbrace{a \cdot a \cdot \ldots \cdot a}_\text{\(b\) раз}.\]
        Главная проблема этой формулы заключается в том, что в ней гораздо больше операций умножения (а именно $b - 1$, что является \(O(b)\)), чем необходимо. Формально говоря, ничего плохого в этом нет, однако, если попробовать воспользоваться этим разложением для подсчёта большой степени на компьютере, то окажется, что при больших значениях \(b\) программа начинает работать очень долго.

        При помощи алгоритма двоичного возведения в степень можно ускорить решение. Рассмотрим случай с чётным ненулевым $b$ (\(b = 2k, k \in \mathbb{N}\)).
        \[a^b = a^{2k} = (a^{2})^k = \underbrace{a^2 \cdot a^2 \cdot \ldots \cdot a^2}_\text{\(k\) раз}.\]
        Для вычисления $a^2$ мы используем $1$ операцию, а для возведения его в степень $k$ ещё $k - 1$ штуку. Таким образом, необходимое количество операций сократилось почти в два раза, однако есть возможность повторно ускорить подсчёт этим же рассуждением, если $k$ тоже окажется чётным.

        Возникает вполне закономерный вопрос: что делать с нечётным $b$. Нечётное $b$ можно разложить как $2k + 1, k \in \mathbb{N}$. Тогда формула обретёт вид:
        \[a^b = a^{2k + 1} = (a^{2})^k \cdot a = \underbrace{a^2 \cdot a^2 \cdot \ldots \cdot a^2}_\text{\(k\) раз} \cdot a.\]
        Всего $k + 1$ операция, что тоже чуть больше половины от исходных $b = 2k + 1$ штук.

        Так как мы разобрались, как можно разложить как чётную степень, так и нечётную, можем продолжить раскладывать её (теперь $k$) дальше. Такой способ позволяет возводить в степень значительно быстрее обычного. Этот алгоритм называется \emph{алгоритмом двоичного возведения в степень} и работает он за \(O(\log_2{b})\) операций.

        Пример реализации:
\begin{lstlisting}
long long bin_pow(long long a, long long b)
{
    if (b == 0) return 1;
    if (b % 2 == 0) return bin_pow(a * a, b / 2);
    return bin_pow(a * a, b / 2) * b;
}
\end{lstlisting}
    \subsection{Вычисления по модулю}

    Мы научились быстро возводить число даже в большую степень, но не сделали важное уточнение. Результат этого возведения может не уместиться в основные встроенные числовые типы многих языков программирования. Поэтому при решении задач, требующих оперирования многозначными числами, часто ответ принимается \emph{по модулю} некоторого числа $MOD$, которое обычно считается равным какому-то простому числу порядка $10^9$ (мы возьмём значение $MOD=10^9+7$). Это значит, что вместо ответа, который оказался равным $MOD$ или больше, нужно выводить только остаток от деления ответа на $MOD$. Может показаться, что это больше усложняет задачу, но по сравнению с альтернативой (длинной арифметикой) это значимое упрощение. Хранение чисел по модулю несколько меняет то, как над ними должны происходить арифметические действия.

    В \textit{C++} числовой тип \textit{long long} может хранить числа порядка $9\cdot 10^{18}$, что при модуле $MOD=10^9+7$ позволяет проводить операции сложения и умножения непосредственным образом.
\begin{lstlisting}
ll a; // 0 <= a < MOD
ll b; // 0 <= b < MOD
ll sum = (a + b) % MOD;  // OK
ll product = (a * b) % MOD;  // OK
\end{lstlisting}

    Встроенный оператор \textit{\%} при попытке деления отрицательного числа на положительное выдаёт отрицательный остаток от деления, поэтому во время вычитания по модулю могут получаться разные значения в зависимости от знака разности чисел.
\begin{lstlisting}
cout << 10 % 7;  // 3
cout << (-10) % 7;  // -3
\end{lstlisting}
    Чтобы поддерживать все используемые числа в промежутке \([0, MOD)\) можно к результату вычитания прибавить $MOD$.
\begin{lstlisting}
ll a; // 0 <= a < MOD
ll b; // 0 <= b < MOD
ll diff = (a + MOD - b) % MOD;  // OK
\end{lstlisting}

    Для возведения в целую неотрицательную степень будем использовать модифицированный алгоритм быстрого возведения в степень. Единственное его отличие от обычного заключается в том, что все операции внутри реализации считаются по модулю (кроме деления).
\begin{lstlisting}
ll bin_pow(ll a, ll b)
{
    if (b == 0) return 1;
    if (b % 2 == 0) return bin_pow((a * a) % MOD, b / 2);
    return (bin_pow((a * a) % MOD, b / 2) * b) % MOD;
}
\end{lstlisting}

    Здесь не было необходимости вычислять деление по модулю, так как $b$ ни в какой момент времени не достигло $MOD$. Это означает, что оно никаким образом не отличалось от обычного числа, хранящегося не по модулю. Хотя в общем случае деление двух чисел по модулю по-обычному сделать не получится.
\begin{lstlisting}
ll a = 3;
ll b = 4;
ll MOD = 7;
ll product = (a * b) % MOD;  // 12 % 7 = 5
cout << (product / b) % MOD;  // (5 / 4) % 7 = 1 != a
\end{lstlisting}
    Для решения этой проблемы воспользуемся тем фактом, что $MOD$ --- простое число. По \href{https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BB%D0%B0%D1%8F_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%A4%D0%B5%D1%80%D0%BC%D0%B0#%D0%90%D0%BB%D1%8C%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D1%83%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0}{малой теореме Ферма} имеем, что
    \[\frac{a}{b} = a \cdot b^{-1} = a \cdot b^{-2} \cdot b \equiv a \cdot b^{-2} \cdot b^{MOD} \equiv a \cdot b^{MOD - 2} \text{ } (\text{mod } MOD).\]
    Чтобы возвести число $b$ в степень $MOD - 2$, которая обычно оказывается большим числом, следует применить алгоритм быстрого возведения в степень по модулю. 
\newpage
\begin{lstlisting}
ll inverse(ll x)
{
    return bin_pow(x, MOD - 2);
}
\end{lstlisting}
    Тогда
\begin{lstlisting}
ll a;  // 0 <= a < MOD
ll b;  // 0 < b < MOD
ll div = (a * inverse(b)) % MOD;  // OK
\end{lstlisting}
    \subsection{XOR}

    XOR, или операция \emph{исключающего или}, --- математическая операция, принимающая два операнда (обозначается \(a \oplus b\)) и имеющая несколько полезных свойств:
    \begin{itemize}
        \item Перемена мест слагаемых не меняет ответ.
        \item \(x \oplus x = 0\) для любого $x$.
        \item \(x \oplus 0 = x\) для любого $x$.
    \end{itemize}
    Из этих свойств следует, что если некоторое слагаемое встречается в XOR-сумме чётное количество раз, то все его повторения можно исключить, а если нечётное --- то исключить все, кроме одного.

    В этом параграфе разберём следующую задачу, удобно решающуюся с помощью исключающего или. Исходная задача \href{https://codeforces.com/contest/1915/problem/B}{здесь}. Даны три строки, в каждой из которых три символа (``A'', ``B'', ``C''). Как в судоку, в каждой строке и в каждом столбце символы не повторяются. Но вместо одной из букв стоит знак вопроса. Задача заключается в определении того, какой символ заменён знаком вопроса.

    Решать задачу можно уймой разных способов. Однако очень к месту приходится операция XOR. Рассмотрим XOR-сумму всех девяти данных символов, а так же трёх символов ``A'', трёх символов ``B'', трёх символов ``C'' и одного вопросительного знака. В этой сумме каждому знаку, кроме искомого, найдётся парный элемент, вместе с которым он сократится. После всех сокращений и останется только один искомый символ.
    
    Например, пусть вопросительным знаком заменена ``A''. Это не умаляет общности примера, потому что при другом недостающем символе все буквы можно переобозначить так, чтобы ответом на задачу оказалась ``А''. Тогда в исходных данных будут две буквы ``A'', три буквы ``B'', три буквы ``C'' и вопросительный знак. В силу того, что в XOR-сумме можно менять местами слагаемые и порядок операций, имеем:
    \[(A \oplus A \oplus B \oplus B \oplus B \oplus C \oplus C \oplus C \oplus ?) \oplus (A \oplus A \oplus A \oplus B \oplus B \oplus B \oplus C \oplus C \oplus C \oplus ?)=\]\[=(A \oplus A \oplus A \oplus A \oplus A) \oplus (B \oplus B \oplus B \oplus B \oplus B \oplus B) \oplus (C \oplus C \oplus C \oplus C \oplus C \oplus C) \oplus (? \oplus ?)=\]\[=A \oplus 0 \oplus 0 \oplus 0 = A.\]

    Один из вариантов записать это решение:
\begin{lstlisting}
#include <iostream>
using namespace std;

void solve()
{
    string s1, s2, s3;
    cin >> s1 >> s2 >> s3;
    
    char result = 0;
    for (char c : s1) result = result ^ c;
    for (char c : s2) result = result ^ c;
    for (char c : s3) result = result ^ c;
    for (char c : "AAABBBCCC?") result = result ^ c;
    cout << result << '\n';
}

int main()
{
    int t; cin >> t;
    while(t--) solve();
}
\end{lstlisting}

    Есть много других задач, решаемых с помощью XOR. Нередко их объединяют какие-либо рассуждения о чётности.
    \subsection{Алгоритм Евклида}
    \subsection{Решето Эратосфена}
\section{Стандартные контейнеры}
    \subsection{vector}
    \subsection{list}
    \subsection{set}
    \subsection{unordered\_set}
    \subsection{map}
    \subsection{unordered\_map}
\section{Структуры данных}
    \subsection{Префиксные суммы}
    \subsection{Дерево отрезков}
    \subsection{Система непересекающихся множеств}
    \subsection{Бор}
\section{Графы}
    \subsection{Обход графа}
    \subsection{Кратчайший путь}
\section{Строки}
    \subsection{Полиномиальные хеши}
\section{Разбиение на подзадачи}
    \subsection{Рекурсия}
    \subsection{Мемоизация}
    \subsection{Динамическое программирование}
        \subsubsection{ДП по маскам}
        \subsubsection{ДП по подотрезкам}
        \subsubsection{ДП по поддеревьям}
\section{Это не всё}

\end{document}