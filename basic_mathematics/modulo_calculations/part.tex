\subsection{Вычисления по модулю}

    Мы научились быстро возводить число даже в большую степень, но не сделали важное уточнение. Результат этого возведения может не уместиться в основные встроенные числовые типы многих языков программирования. Поэтому при решении задач, требующих оперирования многозначными числами, часто ответ принимается \emph{по модулю} некоторого числа $MOD$, которое обычно считается равным какому-то простому числу порядка $10^9$ (мы возьмём значение $MOD=10^9+7$). Это значит, что вместо ответа, который оказался равным $MOD$ или больше, нужно выводить только остаток от деления ответа на $MOD$. Может показаться, что это больше усложняет задачу, но по сравнению с альтернативой (длинной арифметикой) это значимое упрощение. Хранение чисел по модулю несколько меняет то, как над ними должны происходить арифметические действия.

    В \textit{C++} числовой тип \textit{long long} может хранить числа порядка $9\cdot 10^{18}$, что при модуле $MOD=10^9+7$ позволяет проводить операции сложения и умножения непосредственным образом.
\begin{lstlisting}
ll a; // 0 <= a < MOD
ll b; // 0 <= b < MOD
ll sum = (a + b) % MOD;  // OK
ll product = (a * b) % MOD;  // OK
\end{lstlisting}

    Встроенный оператор \textit{\%} при попытке деления отрицательного числа на положительное выдаёт отрицательный остаток от деления, поэтому во время вычитания по модулю могут получаться разные значения в зависимости от знака разности чисел.
\begin{lstlisting}
cout << 10 % 7;  // 3
cout << (-10) % 7;  // -3
\end{lstlisting}
    Чтобы поддерживать все используемые числа в промежутке \([0, MOD)\) можно к результату вычитания прибавить $MOD$.
\begin{lstlisting}
ll a; // 0 <= a < MOD
ll b; // 0 <= b < MOD
ll diff = (a + MOD - b) % MOD;  // OK
\end{lstlisting}

    Для возведения в целую неотрицательную степень будем использовать модифицированный алгоритм быстрого возведения в степень. Единственное его отличие от обычного заключается в том, что все операции внутри реализации считаются по модулю (кроме деления).
\begin{lstlisting}
ll bin_pow(ll a, ll b)
{
    if (b == 0) return 1;
    if (b % 2 == 0) return bin_pow((a * a) % MOD, b / 2);
    return (bin_pow((a * a) % MOD, b / 2) * b) % MOD;
}
\end{lstlisting}

    Здесь не было необходимости вычислять деление по модулю, так как $b$ ни в какой момент времени не достигло $MOD$. Это означает, что оно никаким образом не отличалось от обычного числа, хранящегося не по модулю. Хотя в общем случае деление двух чисел по модулю по-обычному сделать не получится.
\begin{lstlisting}
ll a = 3;
ll b = 4;
ll MOD = 7;
ll product = (a * b) % MOD;  // 12 % 7 = 5
cout << (product / b) % MOD;  // (5 / 4) % 7 = 1 != a
\end{lstlisting}
    Для решения этой проблемы воспользуемся тем фактом, что $MOD$ --- простое число. По \href{https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BB%D0%B0%D1%8F_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%A4%D0%B5%D1%80%D0%BC%D0%B0#%D0%90%D0%BB%D1%8C%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D1%83%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0}{малой теореме Ферма} имеем, что
    \[\frac{a}{b} = a \cdot b^{-1} = a \cdot b^{-2} \cdot b \equiv a \cdot b^{-2} \cdot b^{MOD} \equiv a \cdot b^{MOD - 2} \text{ } (\text{mod } MOD).\]
    Чтобы возвести число $b$ в степень $MOD - 2$, которая обычно оказывается большим числом, следует применить алгоритм быстрого возведения в степень по модулю. 
\newpage
\begin{lstlisting}
ll inverse(ll x)
{
    return bin_pow(x, MOD - 2);
}
\end{lstlisting}
    Тогда
\begin{lstlisting}
ll a;  // 0 <= a < MOD
ll b;  // 0 < b < MOD
ll div = (a * inverse(b)) % MOD;  // OK
\end{lstlisting}