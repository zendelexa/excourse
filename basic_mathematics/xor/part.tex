\subsection{XOR}

    XOR, или операция \emph{исключающего или}, --- математическая операция, принимающая два операнда (обозначается \(a \oplus b\)) и имеющая несколько полезных свойств:
    \begin{itemize}
        \item Перемена мест слагаемых не меняет ответ.
        \item \(x \oplus x = 0\) для любого $x$.
        \item \(x \oplus 0 = x\) для любого $x$.
    \end{itemize}
    Из этих свойств следует, что если некоторое слагаемое встречается в XOR-сумме чётное количество раз, то все его повторения можно исключить, а если нечётное --- то исключить все, кроме одного.

    В этом параграфе разберём следующую задачу, удобно решающуюся с помощью исключающего или. Исходная задача \href{https://codeforces.com/contest/1915/problem/B}{здесь}. Даны три строки, в каждой из которых три символа (``A'', ``B'', ``C''). Как в судоку, в каждой строке и в каждом столбце символы не повторяются. Но вместо одной из букв стоит знак вопроса. Задача заключается в определении того, какой символ заменён знаком вопроса.

    Решать задачу можно уймой разных способов. Однако очень к месту приходится операция XOR. Рассмотрим XOR-сумму всех девяти данных символов, а так же трёх символов ``A'', трёх символов ``B'', трёх символов ``C'' и одного вопросительного знака. В этой сумме каждому знаку, кроме искомого, найдётся парный элемент, вместе с которым он сократится. После всех сокращений и останется только один искомый символ.
    
    Например, пусть вопросительным знаком заменена ``A''. Это не умаляет общности примера, потому что при другом недостающем символе все буквы можно переобозначить так, чтобы ответом на задачу оказалась ``А''. Тогда в исходных данных будут две буквы ``A'', три буквы ``B'', три буквы ``C'' и вопросительный знак. В силу того, что в XOR-сумме можно менять местами слагаемые и порядок операций, имеем:
    \[(A \oplus A \oplus B \oplus B \oplus B \oplus C \oplus C \oplus C \oplus ?) \oplus (A \oplus A \oplus A \oplus B \oplus B \oplus B \oplus C \oplus C \oplus C \oplus ?)=\]\[=(A \oplus A \oplus A \oplus A \oplus A) \oplus (B \oplus B \oplus B \oplus B \oplus B \oplus B) \oplus (C \oplus C \oplus C \oplus C \oplus C \oplus C) \oplus (? \oplus ?)=\]\[=A \oplus 0 \oplus 0 \oplus 0 = A.\]

    Один из вариантов записать это решение:
\begin{lstlisting}
#include <iostream>
using namespace std;

void solve()
{
    string s1, s2, s3;
    cin >> s1 >> s2 >> s3;
    
    char result = 0;
    for (char c : s1) result = result ^ c;
    for (char c : s2) result = result ^ c;
    for (char c : s3) result = result ^ c;
    for (char c : "AAABBBCCC?") result = result ^ c;
    cout << result << '\n';
}

int main()
{
    int t; cin >> t;
    while(t--) solve();
}
\end{lstlisting}

    Есть много других задач, решаемых с помощью XOR. Нередко их объединяют какие-либо рассуждения о чётности.