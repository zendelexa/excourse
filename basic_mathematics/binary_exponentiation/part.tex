\subsection{Быстрое возведение в степень}
Текущая задача ставится очень просто: возвести некоторое число \(a\) в степень \(b\). Ограничимся тем, что $a$ и $b$ --- неотрицательные целые числа. На этом примере будет явно видна суть использования эффективных алгоритмов.

Итак, возведение в степень можно по определению расписать в виде кратного умножения.
\[a^b=\underbrace{a \cdot a \cdot  \ldots \cdot a}_\text{\(b\) раз}.\]
Главная проблема этой формулы заключается в том, что в ней гораздо больше операций умножения (а именно $b - 1$, что является \(O(b)\)), чем необходимо. Формально говоря, ничего плохого в этом нет, однако, если попробовать воспользоваться этим разложением для подсчёта большой степени на компьютере, то окажется, что при больших значениях \(b\) программа начинает работать очень долго.

При помощи алгоритма двоичного возведения в степень можно ускорить решение. Рассмотрим случай с чётным ненулевым $b$ (\(b = 2k, k \in \mathbb{N}\)).
\[a^b = a^{2k} = (a^{2})^k = \underbrace{a^2 \cdot a^2 \cdot \ldots \cdot a^2}_\text{\(k\) раз}.\]
Для вычисления $a^2$ мы используем $1$ операцию, а для возведения его в степень $k$ ещё $k - 1$ штуку. Таким образом, необходимое количество операций сократилось почти в два раза, однако есть возможность повторно ускорить подсчёт этим же рассуждением, если $k$ тоже окажется чётным.

Возникает вполне закономерный вопрос: что делать с нечётным $b$. Нечётное $b$ можно разложить как $2k + 1, k \in \mathbb{N}$. Тогда формула обретёт вид:
\[a^b = a^{2k + 1} = (a^{2})^k \cdot a = \underbrace{a^2 \cdot a^2 \cdot \ldots \cdot a^2}_\text{\(k\) раз} \cdot a.\]
Всего $k + 1$ операция, что тоже чуть больше половины от исходных $b = 2k + 1$ штук.

Так как мы разобрались, как можно разложить как чётную степень, так и нечётную, можем продолжить раскладывать её (теперь $k$) дальше. Такой способ позволяет возводить в степень значительно быстрее обычного. Этот алгоритм называется \emph{алгоритмом двоичного возведения в степень} и работает он за \(O(\log_2{b})\) операций.


Пример реализации:
\begin{lstlisting}
long long bin_pow(long long a, long long b)
{
if (b == 0) return 1;
if (b % 2 == 0) return bin_pow(a * a, b / 2);
return bin_pow(a * a, b / 2) * b;
}
\end{lstlisting}