\subsection{Задача о поиске в отсортированном массиве}
Пусть дан упорядоченный набор чисел $a_1, a_2, \ldots, a_n$ такой, что $a_1 \le a_2 \le \ldots \le a_n$. Нужно проверить наличие элемента, равного некоторому целевому значению $t$.

\subsection*{Наивное решение}
Будем проверять все элементы по очереди. Если значение какого-то из них равно $t$, то, очевидно, искомый элемент имеется. В противном случае --- не имеется.

Код решения использует контейнер \lstinline|vector|, который будет рассмотрен позже. Здесь нас интересует только сложность алгоритма.
\begin{lstlisting}
bool lookFor(vector<int> &a, int t)
{
    int n = a.size();
    for (int i = 0; i < n; i++)
    {
        if (a[i] == t)
        {
            return true;
        }
    }
    return false;
}
\end{lstlisting}

Количество операций в каждой итерации цикла не зависит от $n$, а, следовательно, эти итерации имеют константную сложность. Так как цикл произведёт не более $n$ итераций (он остановится раньше, если найдёт искомый элемент), знаем, что сложность цикла --- линейная. Вычисление размера массива и возвращение ответа через $return$ выполняются за константное время. В итоге, всё решение имеет сложность $O(n)$.

\subsection*{Оптимальное решение}
Решение можно ускорить, если воспользоваться фактом отсортированности массива. Из него следует, что если некоторый элемент $a_i$ массива \emph{меньше} $t$, то все элементы \emph{слева} от $a_i$ так же обязаны быть меньше $t$ и, следовательно, рассмотрению не подлежат. Аналогично, все элементы справа от элемента, превосходящего $t$, не интересуют нас.

Возьмём элемент $a_i$ в середине массива. Получим три случая:
\begin{enumerate}
    \item $a_i$ равен $t$. Искомый элемент найден, задача решена.
    \item $a_i$ меньше $t$. Все элементы слева исключаем из рассмотрения.
    \item $a_i$ больше $t$. Исключаем все элементы справа.
\end{enumerate}
После такого, если только алгоритм не завершит работу, зона поиска сократится приблизительно вдвое. Теперь проведём те же рассуждения с элементом $a_j$, находящимся посередине новой зоны поиска.

Видно, что зона поиска не может сократиться вдвое более $\lceil\log_2{n}\rceil$ раз, где угловые скобки означают округление вверх. Таким образом, алгоритм совершит не более $\lceil\log_2{n}\rceil$ итераций, каждая из которых выполняется за константое время. Заключаем, что общая сложность --- $O(\log{n})$ (округление вверх убрано, так как оно в худшем случае добавляет одну итерацию и позволима оценка $\lceil\log_2{n}\rceil \le 2 \cdot \log_2{n}$).

Такой процесс называется \emph{двоичным поиском} и будет рассмотрен в более общем случае позже.